# read.csv 

## Exercise

The `utils` package, which is automatically loaded in your R session on startup, can import CSV files with the [`read.csv()`](http://www.rdocumentation.org/packages/utils/functions/read.table) function.

In this exercise, you'll be working with [`swimming_pools.csv`](http://s3.amazonaws.com/assets.datacamp.com/production/course_1477/datasets/swimming_pools.csv); it contains data on swimming pools in Brisbane, Australia (Source: [data.gov.au](https://data.gov.au/dataset/swimming-pools-brisbane-city-council)). The file contains the column names in the first row. It uses a comma to separate values within rows.

Type [`dir()`](http://www.rdocumentation.org/packages/base/functions/list.files) in the console to list the files in your working directory. You'll see that it contains `swimming_pools.csv`, so you can start straight away.

## Instructions

Use [`read.csv()`](http://www.rdocumentation.org/packages/utils/functions/read.table) to import `"swimming_pools.csv"` as a data frame with the name `pools`.
Print the structure of `pools` using [`str()`](http://www.rdocumentation.org/packages/utils/functions/str).

## Code

```
# Import swimming_pools.csv: pools
# Print the structure of pools
 
```

```
# Import swimming_pools.csv: pools
pools &lt;- read.csv("swimming_pools.csv")
# Print the structure of pools
str(pools)
 
```

Great! Continue to the next exercise.

# stringsAsFactors 

## Exercise

With `stringsAsFactors`, you can tell R whether it should convert strings in the flat file to factors.

For all importing functions in the `utils` package, this argument is `TRUE`, which means that you import strings as factors. This only makes sense if the strings you import represent categorical variables in R. If you set `stringsAsFactors` to `FALSE`, the data frame columns corresponding to strings in your text file will be `character`.

You'll again be working with the [`swimming_pools.csv`](http://s3.amazonaws.com/assets.datacamp.com/production/course_1477/datasets/swimming_pools.csv) file. It contains two columns (`Name` and `Address`), which shouldn't be factors.

## Instructions

Use `read.csv()` to import the data in [`"swimming_pools.csv"`](http://s3.amazonaws.com/assets.datacamp.com/production/course_1477/datasets/swimming_pools.csv) as a data frame called `pools`; make sure that strings are imported as characters, not as factors.
Using [`str()`](http://www.rdocumentation.org/packages/utils/functions/str), display the structure of the dataset and check that you indeed get character vectors instead of factors.

## Code

```
# Import swimming_pools.csv correctly: pools
# Check the structure of pools
 
```

```
# Import swimming_pools.csv correctly: pools
pools &lt;- read.csv("swimming_pools.csv", stringsAsFactors = FALSE)
# Check the structure of pools
str(pools)
 
```

Great job!

# Any changes? 

## Exercise

Consider the code below that loads data in `swimming_pools.csv` in two distinct ways:

    # Option A
    pools <- read.csv("swimming_pools.csv", stringsAsFactors = TRUE)

    # Option B
    pools <- read.csv("swimming_pools.csv", stringsAsFactors = FALSE)

How many variables in the resulting `pools` data frame have different types if you specify the `stringsAsFactors` argument differently?

The [`swimming_pools.csv`](http://s3.amazonaws.com/assets.datacamp.com/production/course_1477/datasets/swimming_pools.csv) file is available in your current working directory so you can experiment in the console.

## Choices

* Just one: <code>Name</code>.
* Two variables: <code>Name</code> and <code>Address</code>.
* Three columns: all but <code>Longitude</code>.
* All four of them!

**Correct answer: **



# read.delim 

## Exercise

Aside from `.csv` files, there are also the `.txt` files which are basically text files. You can import these functions with [`read.delim()`](http://www.rdocumentation.org/packages/utils/functions/read.table). By default, it sets the `sep` argument to `"\t"` (fields in a record are delimited by tabs) and the `header` argument to `TRUE` (the first row contains the field names).

In this exercise, you will import [`hotdogs.txt`](http://s3.amazonaws.com/assets.datacamp.com/production/course_1477/datasets/hotdogs.txt), containing information on sodium and calorie levels in different hotdogs (Source: [UCLA](http://wiki.stat.ucla.edu/socr/index.php/SOCR_012708_ID_Data_HotDogs)). The dataset has 3 variables, but the variable names are *not* available in the first line of the file. The file uses tabs as field separators.

## Instructions

Import the data in `"hotdogs.txt"` with [`read.delim()`](http://www.rdocumentation.org/packages/utils/functions/read.table). Call the resulting data frame `hotdogs`. The variable names are **not** on the first line, so make sure to set the `header` argument appropriately.
Call [`summary()`](http://www.rdocumentation.org/packages/base/functions/summary) on `hotdogs`. This will print out some summary statistics about all variables in the data frame.

## Code

```
# Import hotdogs.txt: hotdogs
# Summarize hotdogs
 
```

```
# Import hotdogs.txt: hotdogs
hotdogs &lt;- read.delim("hotdogs.txt", header = FALSE)
# Summarize hotdogs
summary(hotdogs)
 
```

Nice one! You are now able to import `.txt` files on your own!

# read.table 

## Exercise

If you're dealing with more exotic flat file formats, you'll want to use [`read.table()`](http://www.rdocumentation.org/packages/utils/functions/read.table). It's the most basic importing function; you can specify tons of different arguments in this function. Unlike [`read.csv()`](http://www.rdocumentation.org/packages/utils/functions/read.table) and [`read.delim()`](http://www.rdocumentation.org/packages/utils/functions/read.table), the `header` argument defaults to `FALSE` and the `sep` argument is `""` by default.

Up to you again! The data is still [`hotdogs.txt`](http://s3.amazonaws.com/assets.datacamp.com/production/course_1477/datasets/hotdogs.txt). It has no column names in the first row, and the field separators are tabs. This time, though, the file is in the `data` folder inside your current working directory. A variable `path` with the location of this file is already coded for you.

## Instructions

Finish the `read.table()` call that's been prepared for you. Use the `path` variable, and make sure to set `sep` correctly.
Call `head()` on `hotdogs`; this will print the first 6 observations in the data frame.

## Code

```
# Path to the hotdogs.txt file: path
path &lt;- file.path("data", "hotdogs.txt")
# Import the hotdogs.txt file: hotdogs
hotdogs &lt;- read.table(___,
sep = ___,
col.names = c("type", "calories", "sodium"))
# Call head() on hotdogs
 
```

```
# Path to the hotdogs.txt file: path
path &lt;- file.path("data", "hotdogs.txt")
# Import the hotdogs.txt file: hotdogs
hotdogs &lt;- read.table(path,
sep = "t",
col.names = c("type", "calories", "sodium"))
# Call head() on hotdogs
head(hotdogs)
 
```

Great! No need to specify the `header` argument: it is `FALSE` by default for `read.table()`, which is exactly what you want here.

# Arguments 

## Exercise

Lily and Tom are having an argument because they want to share a hot dog but they can't seem to agree on which one to choose. After some time, they simply decide that they will have one each. Lily wants to have the one with the fewest calories while Tom wants to have the one with the most sodium.

Next to `calories` and `sodium`, the hotdogs have one more variable: `type`. This can be one of three things: `Beef`, `Meat`, or `Poultry`, so a categorical variable: a factor is fine.

## Instructions

Finish the `read.delim()` call to import the data in [`"hotdogs.txt"`](http://s3.amazonaws.com/assets.datacamp.com/production/course_1477/datasets/hotdogs.txt). It's a tab-delimited file without names in the first row.
The code that selects the observation with the lowest calorie count and stores it in the variable `lily` is already available. It uses the function [`which.min()`](http://www.rdocumentation.org/packages/base/functions/which.min), that returns the index the smallest value in a vector.
Do a similar thing for Tom: select the observation with the *most sodium* and store it in `tom`. Use [`which.max()`](http://www.rdocumentation.org/packages/base/functions/which.min) this time.
Finally, print both the observations `lily` and `tom`.

## Code

```
# Finish the read.delim() call
hotdogs &lt;- read.delim("hotdogs.txt", header = ___, col.names = c("type", "calories", ___))
# Select the hot dog with the least calories: lily
lily &lt;- hotdogs[which.min(hotdogs$calories), ]
# Select the observation with the most sodium: tom
# Print lily and tom
 
```

```
# Finish the read.delim() call
hotdogs &lt;- read.delim("hotdogs.txt", header = FALSE, col.names = c("type", "calories", "sodium"))
# Select the hot dog with the least calories: lily
lily &lt;- hotdogs[which.min(hotdogs$calories), ]
# Select the observation with the most sodium: tom
tom &lt;- hotdogs[which.max(hotdogs$sodium), ]
# Print lily and tom
lily
tom
 
```

Congratulations!

# Column classes 

## Exercise

Next to column names, you can also specify the column types or column classes of the resulting data frame. You can do this by setting the `colClasses` argument to a vector of strings representing classes:

    read.delim("my_file.txt", 
               colClasses = c("character",
                              "numeric",
                              "logical"))

This approach can be useful if you have some columns that should be factors and others that should be characters. You don't have to bother with `stringsAsFactors` anymore; just state for each column what the class should be.

If a column is set to `"NULL"` in the `colClasses` vector, this column will be skipped and will not be loaded into the data frame.

## Instructions

The `read.delim()` call from before is already included and creates the `hotdogs` data frame. Go ahead and display the structure of `hotdogs`.
**Edit** the second [`read.delim()`](http://www.rdocumentation.org/packages/utils/functions/read.table) call. Assign the correct vector to the `colClasses` argument. `NA` should be replaced with a character vector: `c("factor", "NULL", "numeric")`.
Display the structure of `hotdogs2` and look for the difference.

## Code

```
# Previous call to import hotdogs.txt
hotdogs &lt;- read.delim("hotdogs.txt", header = FALSE, col.names = c("type", "calories", "sodium"))
# Display structure of hotdogs
# Edit the colClasses argument to import the data correctly: hotdogs2
hotdogs2 &lt;- read.delim("hotdogs.txt", header = FALSE,
col.names = c("type", "calories", "sodium"),
colClasses = NA)
# Display structure of hotdogs2
 
```

```
# Previous call to import hotdogs.txt
hotdogs &lt;- read.delim("hotdogs.txt", header = FALSE, col.names = c("type", "calories", "sodium"))
# Display structure of hotdogs
str(hotdogs)
# Edit the colClasses argument to import the data correctly: hotdogs2
hotdogs2 &lt;- read.delim("hotdogs.txt", header = FALSE,
col.names = c("type", "calories", "sodium"),
colClasses = c("factor", "NULL", "numeric"))
# Display structure of hotdogs2
str(hotdogs2)
 
```

Nice! Head over to the next video!

