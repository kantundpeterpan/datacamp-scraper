# read_csv 

## Exercise

CSV files can be imported with [`read_csv()`](http://www.rdocumentation.org/packages/readr/versions/1.0.0/topics/read_delim). It's a wrapper function around [`read_delim()`](http://www.rdocumentation.org/packages/readr/versions/1.0.0/topics/read_delim) that handles all the details for you. For example, it will assume that the first row contains the column names.

The dataset you'll be working with here is [`potatoes.csv`](http://s3.amazonaws.com/assets.datacamp.com/production/course_1477/datasets/potatoes.csv). It gives information on the impact of storage period and cooking on potatoes' flavor. It uses commas to delimit fields in a record, and contains column names in the first row. The file is available in your workspace. Remember that you can inspect your workspace with `dir()`.

## Instructions

Load the `readr` package with [`library()`](http://www.rdocumentation.org/packages/base/functions/library). It's already installed on DataCamp's servers.
Import `"potatoes.csv"` using `read_csv()`. Assign the resulting data frame to the variable `potatoes`.

## Code

```
# Load the readr package
# Import potatoes.csv with read_csv(): potatoes
 
```

```
# Load the readr package
library(readr)
# Import potatoes.csv with read_csv(): potatoes
potatoes &lt;- read_csv("potatoes.csv")
 
```

Good work!

# read_tsv 

## Exercise

Where you use `read_csv()` to easily read in CSV files, you use [`read_tsv()`](http://www.rdocumentation.org/packages/readr/versions/1.0.0/topics/read_delim) to easily read in TSV files. TSV is short for tab-seperated values.

This time, the potatoes data comes in the form of a tab-separated values file; [`potatoes.txt`](http://s3.amazonaws.com/assets.datacamp.com/production/course_1477/datasets/potatoes.txt) is available in your workspace. In contrast to `potatoes.csv`, this file does **not** contain columns names in the first row, though.

There's a vector `properties` that you can use to specify these column names manually.

## Instructions

Use `read_tsv()` to import the potatoes data from `potatoes.txt` and store it in the data frame `potatoes`. In addition to the path to the file, you'll also have to specify the `col_names` argument; you can use the `properties` vector for this.
Call `head()` on `potatoes` to show the first observations of your dataset.

## Code

```
# readr is already loaded
# Column names
properties &lt;- c("area", "temp", "size", "storage", "method",
"texture", "flavor", "moistness")
# Import potatoes.txt: potatoes
# Call head() on potatoes
 
```

```
# readr is already loaded
# Column names
properties &lt;- c("area", "temp", "size", "storage", "method",
"texture", "flavor", "moistness")
# Import potatoes.txt: potatoes
potatoes &lt;- read_tsv("potatoes.txt", col_names = properties)
# Call head() on potatoes
head(potatoes)
 
```

Great work! Let's learn some more about the `read_delim()` function!

# read_delim 

## Exercise

Just as [`read.table()`](http://www.rdocumentation.org/packages/utils/functions/read.table) was the main `utils` function, [`read_delim()`](http://www.rdocumentation.org/packages/readr/versions/1.0.0/topics/read_delim) is the main `readr` function.

[`read_delim()`](http://www.rdocumentation.org/packages/readr/versions/1.0.0/topics/read_delim) takes two mandatory arguments:

-   `file`: the file that contains the data
-   `delim`: the character that separates the values in the data file

You'll again be working [`potatoes.txt`](http://s3.amazonaws.com/assets.datacamp.com/production/course_1477/datasets/potatoes.txt); the file uses tabs (`"\t"`) to delimit values and does **not** contain column names in its first line. It's available in your working directory so you can start right away. As before, the vector `properties` is available to set the `col_names`.

## Instructions

Import all the data in [`"potatoes.txt"`](http://s3.amazonaws.com/assets.datacamp.com/production/course_1477/datasets/potatoes.txt) using [`read_delim()`](http://www.rdocumentation.org/packages/readr/versions/1.0.0/topics/read_delim); store the resulting data frame in `potatoes`.
Print out `potatoes`.

## Code

```
# readr is already loaded
# Column names
properties &lt;- c("area", "temp", "size", "storage", "method",
"texture", "flavor", "moistness")
# Import potatoes.txt using read_delim(): potatoes
# Print out potatoes
 
```

```
# readr is already loaded
# Column names
properties &lt;- c("area", "temp", "size", "storage", "method",
"texture", "flavor", "moistness")
# Import potatoes.txt using read_delim(): potatoes
potatoes &lt;- read_delim("potatoes.txt", delim = "t", col_names = properties)
# Print out potatoes
potatoes
 
```

Good job! Notice that you could just as well have used [`read_tsv()`](http://www.rdocumentation.org/packages/readr/versions/1.0.0/topics/read_delim) here. Proceed to the next exercise to learn more about `readr` functions.

# skip and n_max 

## Exercise

Through `skip` and `n_max` you can control *which part* of your flat file you're actually importing into R.

-   `skip` specifies the number of lines you're ignoring in the flat file before actually starting to import data.
-   `n_max` specifies the number of lines you're actually importing.

Say for example you have a CSV file with 20 lines, and set `skip = 2` and `n_max = 3`, you're only reading in lines 3, 4 and 5 of the file.

Watch out: Once you `skip` some lines, you also skip the first line that can contain column names!

[`potatoes.txt`](http://s3.amazonaws.com/assets.datacamp.com/production/course_1477/datasets/potatoes.txt), a flat file with tab-delimited records and without column names, is available in your workspace.

## Instructions

Finish the first [`read_tsv()`](http://www.rdocumentation.org/packages/readr/versions/1.0.0/topics/read_delim) call to import observations 7, 8, 9, 10 and 11 from `potatoes.txt`.&lt;/

## Code

```
# readr is already loaded
# Column names
properties &lt;- c("area", "temp", "size", "storage", "method",
"texture", "flavor", "moistness")
# Import 5 observations from potatoes.txt: potatoes_fragment
potatoes_fragment &lt;- read_tsv("potatoes.txt", skip = _, n_max = _, col_names = properties)
 
```

```
# readr is already loaded
# Column names
properties &lt;- c("area", "temp", "size", "storage", "method",
"texture", "flavor", "moistness")
# Import 5 observations from potatoes.txt: potatoes_fragment
potatoes_fragment &lt;- read_tsv("potatoes.txt", skip = 6, n_max = 5, col_names = properties)
 
```

Nice job! Feel free to check out the resulting data frames with `str()` in the console!

# col_types 

## Exercise

You can also specify which types the columns in your imported data frame should have. You can do this with `col_types`. If set to `NULL`, the default, functions from the `readr` package will try to find the correct types themselves. You can manually set the types with a string, where each character denotes the class of the column: `c`haracter, `d`ouble, `i`nteger and `l`ogical. `_` skips the column as a whole.

[`potatoes.txt`](http://s3.amazonaws.com/assets.datacamp.com/production/course_1477/datasets/potatoes.txt), a flat file with tab-delimited records and without column names, is again available in your workspace.

## Instructions

In the second [`read_tsv()`](http://www.rdocumentation.org/packages/readr/versions/1.0.0/topics/read_delim) call, edit the `col_types` argument to import *all* columns as characters (`c`). Store the resulting data frame in `potatoes_char`.
Print out the structure of `potatoes_char` and verify whether all column types are `chr`, short for `character`.

## Code

```
# readr is already loaded
# Column names
properties &lt;- c("area", "temp", "size", "storage", "method",
"texture", "flavor", "moistness")
# Import all data, but force all columns to be character: potatoes_char
potatoes_char &lt;- read_tsv("potatoes.txt", col_types = "iiiiiddd", col_names = properties)
# Print out structure of potatoes_char
 
```

```
# readr is already loaded
# Column names
properties &lt;- c("area", "temp", "size", "storage", "method",
"texture", "flavor", "moistness")
# Import all data, but force all columns to be character: potatoes_char
potatoes_char &lt;- read_tsv("potatoes.txt", col_types = "cccccccc", col_names = properties)
# Print out structure of potatoes_char
str(potatoes_char)
 
```

Nice job!

# col_types with collectors 

## Exercise

Another way of setting the types of the imported columns is using **collectors**. Collector functions can be passed in a [`list()`](http://www.rdocumentation.org/packages/base/functions/list) to the `col_types` argument of `read_` functions to tell them how to interpret values in a column.

For a complete list of collector functions, you can take a look at the [`collector`](http://www.rdocumentation.org/packages/readr/versions/1.0.0/topics/read_delim) documentation. For this exercise you will need two collector functions:

-   `col_integer()`: the column should be interpreted as an integer.
-   `col_factor(levels, ordered = FALSE)`: the column should be interpreted as a factor with `levels`.

In this exercise, you will work with [`hotdogs.txt`](http://s3.amazonaws.com/assets.datacamp.com/production/course_1477/datasets/hotdogs.txt), which is a tab-delimited file without column names in the first row.

## Instructions

`hotdogs` is created for you without setting the column types. Inspect its summary using the [`summary()`](http://www.rdocumentation.org/packages/base/functions/summary) function.
Two collector functions are defined for you: `fac` and `int`. Have a look at them, do you understand what they're collecting?
In the second `read_tsv()` call, edit the `col_types` argument: Pass a `list()` with the elements `fac`, `int` and `int`, so the first column is importead as a factor, and the second and third column as integers.
Create a [`summary()`](http://www.rdocumentation.org/packages/base/functions/summary) of `hotdogs_factor`. Compare this to the summary of `hotdogs`.

## Code

```
# readr is already loaded
# Import without col_types
hotdogs &lt;- read_tsv("hotdogs.txt", col_names = c("type", "calories", "sodium"))
# Display the summary of hotdogs
# The collectors you will need to import the data
fac &lt;- col_factor(levels = c("Beef", "Meat", "Poultry"))
int &lt;- col_integer()
# Edit the col_types argument to import the data correctly: hotdogs_factor
hotdogs_factor &lt;- read_tsv("hotdogs.txt",
col_names = c("type", "calories", "sodium"),
col_types = NULL)
# Display the summary of hotdogs_factor
 
```

```
# readr is already loaded
# Import without col_types
hotdogs &lt;- read_tsv("hotdogs.txt", col_names = c("type", "calories", "sodium"))
# Display the summary of hotdogs
summary(hotdogs)
# The collectors you will need to import the data
fac &lt;- col_factor(levels = c("Beef", "Meat", "Poultry"))
int &lt;- col_integer()
# Edit the col_types argument to import the data correctly: hotdogs_factor
hotdogs_factor &lt;- read_tsv("hotdogs.txt",
col_names = c("type", "calories", "sodium"),
col_types = list(fac, int, int))
# Display the summary of hotdogs_factor
summary(hotdogs_factor)
 
```

Awesome! The summary of `hotdogs_factor` clearly contains more interesting information for the `type` column, right?

# fread 

## Exercise

You still remember how to use [`read.table()`](http://www.rdocumentation.org/packages/utils/functions/read.table), right? Well, [`fread()`](http://www.rdocumentation.org/packages/data.table/functions/fread) is a function that does the same job with very similar arguments. It is extremely easy to use and blazingly fast! Often, simply specifying the path to the file is enough to successfully import your data.

Don't take our word for it, try it yourself! You'll be working with the [`potatoes.csv`](http://s3.amazonaws.com/assets.datacamp.com/production/course_1477/datasets/potatoes.csv) file, that's available in your workspace. Fields are delimited by commas, and the first line contains the column names.

## Instructions

Load the `data.table` package using [`library()`](http://www.rdocumentation.org/packages/base/functions/library); it is already installed on DataCamp's servers.
Import `"potatoes.csv"` with [`fread()`](http://www.rdocumentation.org/packages/data.table/functions/fread). Simply pass it the file path and see if it worked. Store the result in a variable `potatoes`.
Print out `potatoes`.

## Code

```
# load the data.table package
# Import potatoes.csv with fread(): potatoes
# Print out potatoes
 
```

```
# load the data.table package
library(data.table)
# Import potatoes.csv with fread(): potatoes
potatoes &lt;- fread("potatoes.csv")
# Print out potatoes
potatoes
 
```

Amazingly easy, right?

# fread: more advanced use 

## Exercise

Now that you know the basics about [`fread()`](http://www.rdocumentation.org/packages/data.table/functions/fread), you should know about two arguments of the function: `drop` and `select`, to drop or select variables of interest.

Suppose you have a dataset that contains 5 variables and you want to keep the first and fifth variable, named "a" and "e". The following options will all do the trick:

    fread("path/to/file.txt", drop = 2:4)
    fread("path/to/file.txt", select = c(1, 5))
    fread("path/to/file.txt", drop = c("b", "c", "d")
    fread("path/to/file.txt", select = c("a", "e"))

Let's stick with potatoes since we're particularly fond of them here at DataCamp. The data is again available in the file [`potatoes.csv`](http://s3.amazonaws.com/assets.datacamp.com/production/course_1477/datasets/potatoes.csv), containing comma-separated records.

## Instructions

Using [`fread()`](http://www.rdocumentation.org/packages/data.table/functions/fread) and `select` or `drop` as arguments, only import the `texture` and `moistness` columns of the flat file. They correspond to the columns 6 and 8 in `"potatoes.csv"`. Store the result in a variable `potatoes`.
[`plot()`](http://www.rdocumentation.org/packages/graphics/functions/plot) 2 columns of the `potatoes` data frame: `texture` on the x-axis, `moistness` on the y-axis. Use the dollar sign notation twice. Feel free to name your axes and plot.

## Code

```
# fread is already loaded
# Import columns 6 and 8 of potatoes.csv: potatoes
# Plot texture (x) and moistness (y) of potatoes
 
```

```
# fread is already loaded
# Import columns 6 and 8 of potatoes.csv: potatoes
potatoes &lt;- fread("potatoes.csv", select = c(6, 8))
# Plot texture (x) and moistness (y) of potatoes
plot(potatoes$texture, potatoes$moistness)
 
```

Congratulations! We can see that moistness and texture are positively correlated.

# Dedicated classes 

## Exercise

You might have noticed that the [`fread()`](http://www.rdocumentation.org/packages/data.table/functions/fread) function produces data frames that look slightly different when you print them out. That's because another class named `data.table` is assigned to the resulting data frames. The printout of such `data.table` objects is different. Does something similar happen with the data frames generated by `readr`?

In your current working directory, we prepared the [`potatoes.csv`](http://s3.amazonaws.com/assets.datacamp.com/production/course_1477/datasets/potatoes.csv) file. The packages `data.table` and `readr` are both loaded, so you can experiment straight away.

Which of the following statements is true?

## Choices

* <a href="http://www.rdocumentation.org/packages/data.table/functions/fread"><code>fread()</code></a> creates an object whose only class is <code>data.table</code> class. <a href="http://www.rdocumentation.org/packages/readr/versions/1.0.0/topics/read_delim"><code>read_tsv()</code></a> creates an object with class <code>tbl_df</code>.
* The class of the result of <a href="http://www.rdocumentation.org/packages/data.table/functions/fread"><code>fread()</code></a> is only <code>data.table</code>. That of the result of <a href="http://www.rdocumentation.org/packages/readr/versions/1.0.0/topics/read_delim"><code>read_tsv()</code></a> is both <code>tbl_df</code> and <code>tbl</code>.
* The class of the result of <a href="http://www.rdocumentation.org/packages/data.table/functions/fread"><code>fread()</code></a> is both <code>data.table</code> and <code>data.frame</code>. <a href="http://www.rdocumentation.org/packages/readr/versions/1.0.0/topics/read_delim"><code>read_tsv()</code></a> creates an object with three classes: <code>tbl_df</code>, <code>tbl</code> and <code>data.frame</code>.
* <a href="http://www.rdocumentation.org/packages/data.table/functions/fread"><code>fread()</code></a> creates an object of the <code>data.table</code> class, while <a href="http://www.rdocumentation.org/packages/readr/versions/1.0.0/topics/read_delim"><code>read_tsv()</code></a> simply generates a <code>data.frame</code>, nothing more.

**Correct answer: 3**



